package baseband

import chisel3._
import chiseltest._

import org.scalatest.flatspec.AnyFlatSpec
import scala.collection.immutable.Seq

import modem.TestUtility._

class BLEPacketDisassemblerTest extends AnyFlatSpec with ChiselScalatestTester {
  /* Link Layer packet captured using Wireshark and a NRF52840 Dongle w/ BLE sniffer firmware
     Channel 37, AA: 0x8e89bed6
     Note CRC is reversed correctly and can be LSB transmitted like rest of packet
   */
  val ble_pcap = Seq(0x40, 0x14, 0x14, 0x58, 0x93, 0x4d, 0xeb, 0x6a,
                     0x02, 0x01, 0x06, 0x0a, 0xff, 0x4c, 0x00, 0x10,
                     0x05, 0x49, 0x1c, 0xb6, 0x2d, 0x78, 0xa5, 0x93,
                     0x8c)

  it should "Process valid packet" in {
    test(new BLEPacketDisassembler(params)) { c =>
      c.clock.setTimeout(10000)

      c.io.constants.radioMode.poke(RadioMode.BLE)
      c.io.constants.bleChannelIndex.poke(37.U)
      c.io.constants.crcSeed.poke(0x555555.U) // From 3.1.1 CRC generation of Bluetooth Core Specification v5.2

      c.io.in.control.bits.command.poke(PDAControlInputCommands.START_CMD)
      c.io.in.control.valid.poke(true.B)
      c.clock.step()
      c.io.in.control.valid.poke(false.B)

      c.io.in.data.sop.poke(true.B)
      c.clock.step()
      c.io.in.data.sop.poke(false.B)

      c.io.out.data.ready.poke(false.B) // back up into queue

      whitenBytes(ble_pcap, 37).map { b =>
        c.clock.step(255) // 32*8=256 cycles between bytes
        c.io.in.data.data.bits.poke(b.U)
        c.io.in.data.data.valid.poke(true.B)
        c.clock.step()
        c.io.in.data.data.valid.poke(false.B)
      }

      c.io.out.data.ready.poke(true.B) // gather all bytes
      var dewhite: Seq[Int] = Seq()
      while (!c.io.out.control.done.peek().litToBoolean) {
        if (c.io.out.data.valid.peek().litToBoolean) { // fire() not working
          dewhite = dewhite ++ Seq(c.io.out.data.bits.peek().litValue.toInt)
        }
        c.clock.step()
      }

      assert(dewhite == ble_pcap)
      assert(c.io.out.control.length.peek().litValue == (ble_pcap.length - 2 - 3))
      assert(c.io.out.control.flag_crc.peek().litToBoolean == false)
    }
  }

  it should "Process invalid packet" in {
    test(new BLEPacketDisassembler(params)) { c =>
      c.clock.setTimeout(10000)

      c.io.constants.radioMode.poke(RadioMode.BLE)
      c.io.constants.bleChannelIndex.poke(37.U)
      c.io.constants.crcSeed.poke(0x555555.U) // From 3.1.1 CRC generation of Bluetooth Core Specification v5.2

      c.io.in.control.bits.command.poke(PDAControlInputCommands.START_CMD)
      c.io.in.control.valid.poke(true.B)
      c.clock.step()
      c.io.in.control.valid.poke(false.B)

      c.io.in.data.sop.poke(true.B)
      c.clock.step()
      c.io.in.data.sop.poke(false.B)

      c.io.out.data.ready.poke(true.B) // constantly remove stuff
      var done_early = false
      var dewhite: Seq[Int] = Seq()
      val bad_pcap = Seq(0x69, 0x16) ++ ble_pcap

      whitenBytes(bad_pcap, 37).map { b =>
        for (_ <- 0 until 255) {
          if (c.io.out.data.valid.peek().litToBoolean) { // fire() not working
            dewhite = dewhite ++ Seq(c.io.out.data.bits.peek().litValue.toInt)
          }
          if (c.io.in.data.eop.peek().litToBoolean || c.io.out.control.done.peek().litToBoolean) {
            done_early = true
          }
          c.clock.step()
        }
        c.io.in.data.data.bits.poke(b.U)
        c.io.in.data.data.valid.poke(true.B)
        c.clock.step()
        c.io.in.data.data.valid.poke(false.B)
      }
      assert(!done_early)

      var bytes_left = 0
      var has_eop = false
      while (!c.io.out.control.done.peek().litToBoolean) {
        if (c.io.out.data.valid.peek().litToBoolean) { // fire() not working
          dewhite = dewhite ++ Seq(c.io.out.data.bits.peek().litValue.toInt)
          bytes_left += 1
        }
        has_eop |= c.io.in.data.eop.peek().litToBoolean
        c.clock.step()
      }
      assert(bytes_left == 1)
      assert(has_eop)

      assert(dewhite == bad_pcap)
      assert(c.io.out.control.length.peek().litValue == (bad_pcap.length - 2 - 3))
      assert(c.io.out.control.flag_crc.peek().litToBoolean == true) // bad CRC!
    }
  }
}

class LRWPANPacketDisassemblerTest extends AnyFlatSpec with ChiselScalatestTester {
  /* Raw packet generated by hand (CRC is NOT validated)
     TODO capture a real packet with CRC (NRF52840 stock firmware doesn't give CRC)
   */
  val lrwpan_pcap = Seq(0x07, 0x01, 0x02, 0x03, 0x04, 0x05, 0x9b, 0xed)

  it should "Process valid packet" in {
    test(new LRWPANPacketDisassembler(params)) { c =>
      c.clock.setTimeout(10000)

      c.io.constants.radioMode.poke(RadioMode.LRWPAN)
      c.io.constants.crcSeed.poke(0x0000.U) // From Figure 7-4 of IEEE Std 802.15.4-2020

      c.io.in.control.bits.command.poke(PDAControlInputCommands.START_CMD)
      c.io.in.control.valid.poke(true.B)
      c.clock.step()
      c.io.in.control.valid.poke(false.B)

      c.io.in.data.sop.poke(true.B)
      c.clock.step()
      c.io.in.data.sop.poke(false.B)

      c.io.out.data.ready.poke(false.B) // back up into queue

      lrwpan_pcap.map { b =>
        c.clock.step(1023) // 16*32*2=1024 cycles between bytes
        c.io.in.data.data.bits.poke(b.U)
        c.io.in.data.data.valid.poke(true.B)
        c.clock.step()
        c.io.in.data.data.valid.poke(false.B)
      }

      c.io.out.data.ready.poke(true.B) // gather all bytes
      var pcap: Seq[Int] = Seq()
      while (!c.io.out.control.done.peek().litToBoolean) {
        if (c.io.out.data.valid.peek().litToBoolean) { // fire() not working
          pcap = pcap ++ Seq(c.io.out.data.bits.peek().litValue.toInt)
        }
        c.clock.step()
      }

      assert(pcap == lrwpan_pcap)
      assert(c.io.out.control.length.peek().litValue == (lrwpan_pcap.length - 1))
      assert(c.io.out.control.flag_crc.peek().litToBoolean == false)
    }
  }

  it should "Process invalid packet" in {
    test(new LRWPANPacketDisassembler(params)) { c =>
      c.clock.setTimeout(10000)

      c.io.constants.radioMode.poke(RadioMode.LRWPAN)
      c.io.constants.crcSeed.poke(0x0000.U) // From Figure 7-4 of IEEE Std 802.15.4-2020

      c.io.in.control.bits.command.poke(PDAControlInputCommands.START_CMD)
      c.io.in.control.valid.poke(true.B)
      c.clock.step()
      c.io.in.control.valid.poke(false.B)

      c.io.in.data.sop.poke(true.B)
      c.clock.step()
      c.io.in.data.sop.poke(false.B)

      c.io.out.data.ready.poke(true.B) // constantly remove stuff
      var done_early = false
      var pcap: Seq[Int] = Seq()
      val bad_pcap = Seq(0x08) ++ lrwpan_pcap

      bad_pcap.map { b =>
        for (_ <- 0 until 1023) {
          if (c.io.out.data.valid.peek().litToBoolean) { // fire() not working
            pcap = pcap ++ Seq(c.io.out.data.bits.peek().litValue.toInt)
          }
          if (c.io.in.data.eop.peek().litToBoolean || c.io.out.control.done.peek().litToBoolean) {
            done_early = true
          }
          c.clock.step()
        }
        c.io.in.data.data.bits.poke(b.U)
        c.io.in.data.data.valid.poke(true.B)
        c.clock.step()
        c.io.in.data.data.valid.poke(false.B)
      }
      assert(!done_early)

      var bytes_left = 0
      var has_eop = false
      while (!c.io.out.control.done.peek().litToBoolean) {
        if (c.io.out.data.valid.peek().litToBoolean) { // fire() not working
          pcap = pcap ++ Seq(c.io.out.data.bits.peek().litValue.toInt)
          bytes_left += 1
        }
        has_eop |= c.io.in.data.eop.peek().litToBoolean
        c.clock.step()
      }
      assert(bytes_left == 1)
      assert(has_eop)

      assert(pcap == bad_pcap)
      assert(c.io.out.control.length.peek().litValue == (bad_pcap.length - 1))
      assert(c.io.out.control.flag_crc.peek().litToBoolean == true) // bad CRC!
    }
  }
}
