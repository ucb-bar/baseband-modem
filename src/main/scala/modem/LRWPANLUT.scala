package modem

import chisel3._
import chisel3.util._

class ChipToSymbolLUT extends Module {
  val io = IO(new Bundle {
    val chips = Input(UInt(32.W))
    val symbol = Output(UInt(4.W))
  })

  /* MSK-encoded LUT generated by software/models/notebooks/lrwpan.ipynb

     TODO add programmability (need ISA to support 32-bit LUT values)
   */
  val LUT = Seq[UInt](
    "b11001001100010100001000111111000".U(32.W),
    "b10011000101000010001111110001100".U(32.W),
    "b10001010000100011111100011001001".U(32.W),
    "b10100001000111111000110010011001".U(32.W),
    "b00010001111110001100100110001011".U(32.W),
    "b00011111100011001001100010100001".U(32.W),
    "b11111000110010011000101000010000".U(32.W),
    "b10001100100110001010000100011110".U(32.W),
    "b00110110011101011110111000000110".U(32.W),
    "b01100111010111101110000001110010".U(32.W),
    "b01110101111011100000011100110111".U(32.W),
    "b01011110111000000111001101100111".U(32.W),
    "b11101110000001110011011001110101".U(32.W),
    "b11100000011100110110011101011111".U(32.W),
    "b00000111001101100111010111101110".U(32.W),
    "b01110011011001110101111011100000".U(32.W),
  )
  val lut = RegInit(VecInit.tabulate(LUT.length){i => LUT(i)})

  // inspired by https://stackoverflow.com/questions/61052153/how-to-get-the-index-of-max-element-in-uint-vec-chisel
  val hams   = VecInit.tabulate(16){i => PopCount((io.chips ^ lut(i)) >> 1)} // ignore c0
  val minHam = hams.reduceTree {(x,y) => Mux(x < y, x, y)}
  io.symbol := hams.indexWhere((x => x === minHam))
}
